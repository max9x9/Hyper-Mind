<!DOCTYPE html>
<html>
    <head>
        <title>tree-3d</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="stylesheet" href="randomBackground/css/style.css">
		
        <style>
            /*body {
                margin: 0;
                background-color: #f0f0f0;
                color: #fff;
                font-family: Monospace;
                font-size: 13px;
                line-height: 24px;
                overscroll-behavior: none;
            }*/
			a {
				color: #8ff;
			}

			#menu {
				position: absolute;
				bottom: 20px;
				width: 100%;
				text-align: center;
			}

            .border {
                width : 200px;
                text-align: left;
            }
			.element {
                max-width: 260px;
				/*width: 220px;
                height: 60px;*/
                padding : 10px;
				box-shadow: 0px 0px 15px rgba(184, 184, 184, 0.8);
                border: 1px solid rgba(186, 226, 226, 0.25);
                background-color: rgb(156, 0, 0);
                color: rgb(245, 245, 245);
                border-radius: 5px;
				font-family: Helvetica, sans-serif;
				text-align: center;
                vertical-align: center;
                font-size: 20px;
				line-height: normal;
				cursor: default;
			}

			.element:hover {
				box-shadow: 0px 0px 18px rgba(207, 207, 207, 0.8);
				border: 1px solid rgba(218, 215, 215, 0.75);
			}

				.element .number {
					position: absolute;
					top: 20px;
					right: 20px;
					font-size: 12px;
					color: rgba(127,255,255,0.75);
				}

				.element .symbol {
					position: absolute;
					top: 40px;
					left: 0px;
					right: 0px;
					font-size: 60px;
					font-weight: bold;
					color: rgba(255,255,255,0.75);
					text-shadow: 0 0 10px rgba(252, 30, 122, 0.95);
				}

				.element .details {
					position: absolute;
					top: 40px;
					left: 0px;
					right: 0px;
					font-size: 12px;
					color: rgba(127,255,255,0.75);
				}

			button {
				color: rgba(190, 61, 230, 0.75);
				background: transparent;
				outline: 1px solid rgba(153, 9, 236, 0.75);
				border: 0px;
				padding: 5px 10px;
				cursor: pointer;
			}

			button:hover {
				background-color: rgba(255, 91, 219, 0.5);
			}

			button:active {
				color: #000000;
				background-color: rgba(245, 38, 107, 0.75);
			}
        </style>
    </head>
    <body>
            <!-- <div id="container" style="background:url(background2.jpeg) no-repeat;background-size:100% 100%;background-attachment:fixed;"></div> -->
        <div style="position:relative;width: 100%;">
            <div id="welcome">
                    <h1>Hyper-Mind</h1>
            </div>
            <div id="divBack" style="position:absolute; left:0px; top:0px;"></div>
            <div id="container" style="position:absolute; left:0px; top:0px;"></div>
            <div id="menu">
                <button id="btnBack">BACK</button>
            </div>
        </div>
		<script src='js/tree.js/three.min.js'></script>
		<script src="randomBackground/js/index.js"></script>
        <script type="module">
        
            import * as THREE from './js/tree.js/three.module.js';
            import { TWEEN } from './js/jsm/libs/tween.module.min.js';
			import { CSS3DRenderer, CSS3DObject } from './js/jsm/renderers/CSS3DRenderer.js';

            const table = [
                {text:"JAVA并发编程",x:0,y:0},
                {text:"线程基础、线程间的共享和协作",x:1,y:-1.6},
                {text:"原子操作CAS",x:1,y:-0.6},
                {text:"线程并发工具类",x:1,y:0.6},
                {text:"并发安全",x:1,y:1.6},
                {text:"JMM",x:-1,y:-2},
                {text:"显式锁",x:-1,y:-1},
                {text:"AQS同步队列",x:-1,y:0},
                {text:"并发容器",x:-1,y:1},
                {text:"线程池",x:-1,y:2}
            ];

            const table2 = [
                {text:"线程基础、线程间的共享和协作",x:0,y:0},
                {text:"基本概念",x:1,y:4},
                {text:"线程启动方式",x:1,y:3},
                {text:"线程优先级",x:1,y:2},
                {text:"线程间共享",x:1,y:1},
                {text:"线程结束",x:1,y:0},
                {text:"线程状态迁移",x:1,y:-1},
                {text:"守护线程",x:1,y:-2},
                {text:"线程间协作",x:1,y:-3}
            ];


            let root;
            let camera, scene, renderer;
            let scene2, renderer2;
			//let controls;
            let container;

            var objects = [];
            var lines = [];
			const targets = { table: [], sphere: [], helix: [], grid: [] };

            //let group,group2;
            let layer=0;
            let groups=[];
            let groups2=[];
            let targetRotation = 0;
			let targetRotationOnPointerDown = 0;

			let pointerX = 0;
			let pointerXOnPointerDown = 0;
            let windowHalfX = window.innerWidth / 2;

            let widthSpace = 230;
            let heightSpace = 80;

            var lineColor = 0x8A0808;

            init();
            newTree(table,"table");
			animate();
            function newTree(targetTable,tableName){
                let group = new THREE.Group();
                let group2 = new THREE.Group();
                scene2.add(group2);
				scene.add( group);
                groups.push(group);
                groups2.push(group2);
                
                root = targetTable[0];
                targets.table = [];
                objects = [];
                lines = [];
                for (let i =0 ; i< targetTable.length ; i++){

                    // const border = document.createElement("div");
                    // border.className = "border";

                    
                    const element = document.createElement("div");
                    element.id=tableName+""+i;
                    element.className="element";
                    element.textContent = targetTable[i].text;
                    element.style.opacity = 0;
                    /*element.ondblclick = function(){
                        goInto(table2,1000,group,group2);
                    };*/
                    element.onclick = function(){
                        goInto(table2,1000,group,group2);
                    };

                    // border.appendChild(element);
                    //element.style.backgroundColor = 'rgba(0,127,127,' + ( Math.random() * 0.5 + 0.25 ) + ')';

                    /*const text = document.createElement("div");
                    text.classname="details";
                    text.textContent = table[i].text;
                    element.appendChild(text);*/

                    const objectCSS = new CSS3DObject(element);
                    objectCSS.position.x = Math.random() * 4000 - 2000;
                    objectCSS.position.y = Math.random() * 4000 - 2000;
                    objectCSS.position.z = Math.random() * 4000 - 2000;
                    /*objectCSS.position.x = 0;
                    objectCSS.position.y = 0;
                    objectCSS.position.z = -10000;*/
                    
                    group.add( objectCSS );

                    objects.push( objectCSS );
                }
                initLine(targetTable,group2);
                render();

                for (let i =0 ; i< targetTable.length ; i++){
                    const object = new THREE.Object3D();
					object.position.x = ( targetTable[ i ].x * widthSpace );
					object.position.y = ( targetTable[ i ].y * heightSpace );
                    let elementWidth = document.getElementById(tableName+""+i).offsetWidth / 2;
                    if(targetTable[ i ].x>0){
                        object.position.x = object.position.x + elementWidth;
                    }else if(targetTable[ i ].x < 0){
                        object.position.x = object.position.x - elementWidth;
                    }

					targets.table.push( object );
                }

                transform( targets.table, 1000 );
            }
            function init(){

                document.getElementById("btnBack").onclick = function(){goBack(1000);};

                camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;
                scene = new THREE.Scene();
                //scene.background = new THREE.Color( 0xcccccc );
                //scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
                //scene.fog = new THREE.Fog(0xcc0000, 1, 1000);
                //scene.background = new THREE.Color( 0xf0f0f0 );
                //group = new THREE.Group();
                //group2 = new THREE.Group();
				//group.position.y = 100;

                scene2 = new THREE.Scene();
                //scene2.background = new THREE.Color( 0xf0f0f0 );
                //scene2.add(group2);
				//scene.add( group);

                

                renderer2 = new THREE.WebGLRenderer( { antialias: true, alpha: true  } );
                renderer2.setClearAlpha(0);
                renderer2.setPixelRatio( window.devicePixelRatio );
				renderer2.setSize( window.innerWidth, window.innerHeight );
				renderer2.domElement.style.position = 'absolute';
				renderer2.domElement.style.top = 0;
				document.getElementById( 'container' ).appendChild( renderer2.domElement );
                
                renderer = new CSS3DRenderer();
                //renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.getElementById( 'container' ).appendChild( renderer.domElement );
                
                /*controls = new TrackballControls( camera, renderer.domElement );
				controls.minDistance = 500;
				controls.maxDistance = 6000;
				controls.addEventListener( 'change', render );*/
                container = document.getElementById("container");
                container.style.touchAction = 'none';
				container.addEventListener( 'pointerdown', onPointerDown, false );

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function initLine(targetTable,group){

                for(var i=1;i<targetTable.length;i++){
                    var x1 = root.x*230;
                    var y1 = root.y*100;
                    var x2 = targetTable[i].x*widthSpace;
                    var y2 = targetTable[i].y*heightSpace;
                    //var xm=Math.round((x1-x2)/2+x2);
                    //var ym=Math.round((y1-y2)/2+y2);
                    var geometry = new THREE.Geometry();
                    var p1 = new THREE.Vector3(x1, y1, 0);
                    var p2 = new THREE.Vector3(x1, y2, 0);
                    var p3 = new THREE.Vector3(x2, y2, 0);
                    // 三维二次贝赛尔曲线
                    var curve = new THREE.QuadraticBezierCurve3(p1, p2, p3);
                    var points = curve.getPoints(100); //分段数100，返回101个顶点
                    // setFromPoints方法从points中提取数据改变几何体的顶点属性vertices
                    geometry.setFromPoints(points);
                    //材质对象
                    var material = new THREE.LineBasicMaterial({
                        /*color: 0x888888,*/
                        color: lineColor,
                        transparent: true,
                        linewidth: 1,
                        opacity: 0
                    });
                    //线条模型对象
                    var line = new THREE.Line(geometry, material);
                    lines.push(line);
                    group.add(line);
                }


                
                //scene2.add(line); //线条对象添加到场景中
            }

            function goBack(duration){
                if(layer==0) return;
                var group = groups[layer -1];
                var group2 = groups2[layer -1];
                var oldGroup = groups[layer];
                var oldGroup2 = groups2[layer];
                TWEEN.removeAll();
                new TWEEN.Tween( group.position )
                        .to( { x: group.position.x, y: group.position.y, z: 0 }, duration )
                        .easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                new TWEEN.Tween( group2.position )
                        .to( { x: group2.position.x, y: group2.position.y, z: 0 }, duration )
                        .easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                new TWEEN.Tween( oldGroup.position )
                        .to( { x: oldGroup.position.x, y: oldGroup.position.y, z: -1000 }, duration )
                        .easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                new TWEEN.Tween( oldGroup2.position )
                        .to( { x: oldGroup2.position.x, y: oldGroup2.position.y, z: -1000 }, duration )
                        .easing( TWEEN.Easing.Exponential.InOut )
                        .start();

                for(let i=0;i<group.children.length;i++){
                    let element = group.children[i].element;
                    new TWEEN.Tween( {opacity:element.style.opacity*1} )
                        .to( {opacity:1} , duration )
                        .onUpdate(function(o) {
                            element.style.opacity = o.opacity;
                        }).easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                }
                for(let i=0;i<group2.children.length;i++){
                    let targetLine = group2.children[i];
                    new TWEEN.Tween( {opacity:targetLine.material.opacity} )
                        .to( {opacity:1} , duration )
                        .onUpdate(function(o) {
                            targetLine.material.opacity = o.opacity;
                        }).easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                }

                for(let i=0;i<oldGroup.children.length;i++){
                    let element = oldGroup.children[i].element;
                    new TWEEN.Tween( {opacity:element.style.opacity*1} )
                        .to( {opacity:0} , Math.random() * duration )
                        .onUpdate(function(o) {
                            element.style.opacity = o.opacity;
                        }).easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                }
                for(let i=0;i<oldGroup2.children.length;i++){
                    let targetLine = oldGroup2.children[i];
                    new TWEEN.Tween( {opacity:targetLine.material.opacity} )
                        .to( {opacity:0} , Math.random() * duration/2 )
                        .onUpdate(function(o) {
                            targetLine.material.opacity = o.opacity;
                        }).easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                }

                new TWEEN.Tween( this )
                    .to( {}, duration )
                    .onUpdate( render ).onComplete(function(){
                        layer--;
                        removeElement(scene,oldGroup);
                        removeObject(scene,oldGroup);
                        removeObject(scene2,oldGroup2);
                        groups.pop();
                        groups2.pop();
                        render();
                        })
                    .start();
            }

            function removeElement(sce,group){
                for(var i =0;i<group.children.length;i++){
                    var element = group.children[i].element;
                    element.parentNode.removeChild(element);
                }
            }

            function removeObject(sce,group){
                group.traverse(function(obj) {
                    if (obj.type === 'Mesh') {
                        obj.geometry.dispose();
                        obj.material.dispose();
                    }
                })
                // 删除场景对象scene的子对象group
                sce.remove(group);
            }

            function goInto(targetTable,duration,group,group2){
                
                TWEEN.removeAll();
                new TWEEN.Tween( group.position )
                        .to( { x: group.position.x, y: group.position.y, z: 2000 }, duration )
                        .easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                new TWEEN.Tween( group2.position )
                        .to( { x: group2.position.x, y: group2.position.y, z: 2000 }, duration )
                        .easing( TWEEN.Easing.Exponential.InOut )
                        .start();


                for(let i=0;i<group.children.length;i++){
                    let element = group.children[i].element;
                    new TWEEN.Tween( {opacity:element.style.opacity*1} )
                        .to( {opacity:0} , duration/1.5 )
                        .onUpdate(function(o) {
                            element.style.opacity = o.opacity;
                        }).easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                }
                for(let i=0;i<group2.children.length;i++){
                    let targetLine = group2.children[i];
                    new TWEEN.Tween( {opacity:targetLine.material.opacity} )
                        .to( {opacity:0} , duration/1.5 )
                        .onUpdate(function(o) {
                            targetLine.material.opacity = o.opacity;
                        }).easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                }


                new TWEEN.Tween( this )
                    .to( {}, duration/2 )
                    .onUpdate( render ).onComplete(function(){newTree(targetTable,"table2");layer++;})
                    .start();
            }

            function transform( targets, duration ) {

                TWEEN.removeAll();

                for ( let i = 0; i < objects.length; i ++ ) {

                    const object = objects[ i ];
                    const target = targets[ i ];

                    new TWEEN.Tween( object.position )
                        .to( { x: target.position.x, y: target.position.y, z: target.position.z }, Math.random() * duration + duration )
                        .easing( TWEEN.Easing.Exponential.InOut )
                        .start();

                    new TWEEN.Tween( object.rotation )
                        .to( { x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration )
                        .easing( TWEEN.Easing.Exponential.InOut )
                        .start();

                        
                    new TWEEN.Tween( {opacity:object.element.style.opacity*1} )
                        .to( {opacity:1} , Math.random() * duration + duration )
                        .onUpdate(function(o) {
                            object.element.style.opacity = o.opacity;
                        }).easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                }
                

                new TWEEN.Tween( this )
                    .to( {}, duration * 2 )
                    .onUpdate( render ).onComplete(function(){showLines(duration);})
                    .start();

            }

            function showLines(duration){
                TWEEN.removeAll();
                for(var j=0;j < lines.length;j++){
                    let targetLine = lines[j];
                    new TWEEN.Tween( {opacity:targetLine.material.opacity} )
                        .to( {opacity:1} , Math.random() * duration/1.5 )
                        .onUpdate(function(o) {
                            targetLine.material.opacity = o.opacity;
                        }).easing( TWEEN.Easing.Exponential.InOut )
                        .start();
                }
                new TWEEN.Tween( this )
                    .to( {}, duration/1.5 )
                    .onUpdate( render )
                    .start();

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer2.setSize( window.innerWidth, window.innerHeight );

                render();

            }

            function animate() {

                requestAnimationFrame( animate );

                TWEEN.update();
                render();

                //controls.update();

            }

            function render() {
                let group = groups[layer];
                let group2 = groups2[layer];
                group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
                group2.rotation.y += ( targetRotation - group2.rotation.y ) * 0.05;
                renderer.render( scene, camera );
                renderer2.render( scene2, camera );
            }

            function onPointerDown( event ) {

                if ( event.isPrimary === false ) return;

                pointerXOnPointerDown = event.clientX - windowHalfX;
                targetRotationOnPointerDown = targetRotation;

                document.addEventListener( 'pointermove', onPointerMove, false );
                document.addEventListener( 'pointerup', onPointerUp, false );

            }

            function onPointerMove( event ) {

                if ( event.isPrimary === false ) return;

                pointerX = event.clientX - windowHalfX;

                let newRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;
                if(Math.abs(newRotation)>0.6) return;
                targetRotation = newRotation;
                
                //console.log(targetRotation);
            }

            function onPointerUp() {

                if ( event.isPrimary === false ) return;
                targetRotation = 0;
                document.removeEventListener( 'pointermove', onPointerMove );
                document.removeEventListener( 'pointerup', onPointerUp );

            }

        </script>

    </body>
</html>