<!DOCTYPE html>
<html>
    <head>
        <title>tree-3d</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="stylesheet" href="randomBackground/css/style.css">
		<link rel="stylesheet" href="style.css">
    </head>
    <body>
            <!-- <div id="container" style="background:url(background2.jpeg) no-repeat;background-size:100% 100%;background-attachment:fixed;"></div> -->
        <div style="position:relative;width: 100%;">
            <div id="welcome">
                    <h1>Hyper-Mind</h1>
            </div>
            <div id="divBack" style="position:absolute; left:0px; top:0px;"></div>
            <div id="container" style="position:absolute; left:0px; top:0px;"></div>
            <div id="menu">
                <button id="btnBack">BACK</button>
            </div>
        </div>
		<script src='js/tree.js/three.min.js'></script>
        <script src="randomBackground/js/index.js"></script>
        <script type="module">
            import { HyperMind } from './hypermind.js';
            import { SceneHandler } from './defaultSceneHandler.js';

            var hym = new HyperMind();
            hym.data=[{"id":"217","isroot":true,"text":"JAVA并发编程"},{"direction":"right","hasRemark":"0","hasSubtree":"1","id":"218","isroot":false,"parentId":"217","text":"线程基础、线程间的共享和协作"},{"direction":"right","hasRemark":"0","hasSubtree":"1","id":"220","isroot":false,"parentId":"217","text":"原子操作CAS"},{"direction":"right","hasRemark":"0","hasSubtree":"1","id":"219","isroot":false,"parentId":"217","text":"线程并发工具类"},{"direction":"right","hasRemark":"0","hasSubtree":"1","id":"221","isroot":false,"parentId":"217","text":"并发安全"},{"direction":"left","hasRemark":"0","hasSubtree":"1","id":"222","isroot":false,"parentId":"217","text":"JMM"},{"direction":"left","hasRemark":"0","hasSubtree":"1","id":"223","isroot":false,"parentId":"217","text":"显式锁"},{"direction":"left","hasRemark":"0","hasSubtree":"1","id":"224","isroot":false,"parentId":"217","text":"AQS"},{"direction":"left","hasRemark":"0","hasSubtree":"1","id":"225","isroot":false,"parentId":"217","text":"并发容器"},{"direction":"left","hasRemark":"0","hasSubtree":"1","id":"226","isroot":false,"parentId":"217","text":"线程池"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"227","isroot":false,"parentId":"218","text":"基本概念"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"228","isroot":false,"parentId":"218","text":"线程启动方式"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"229","isroot":false,"parentId":"218","text":"线程结束"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"230","isroot":false,"parentId":"218","text":"线程状态迁移"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"231","isroot":false,"parentId":"218","text":"线程优先级"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"232","isroot":false,"parentId":"218","text":"守护线程"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"233","isroot":false,"parentId":"218","text":"线程间共享"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"234","isroot":false,"parentId":"218","text":"线程间协作"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"235","isroot":false,"parentId":"219","text":"Fork/Join 分而治之"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"236","isroot":false,"parentId":"219","text":"CountDownLatch"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"237","isroot":false,"parentId":"219","text":"CyclicBarrier"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"238","isroot":false,"parentId":"219","text":"Semaphore"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"239","isroot":false,"parentId":"219","text":"Exchange"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"241","isroot":false,"parentId":"219","text":"FutureTask"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"242","isroot":false,"parentId":"220","text":"CAS原理"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"243","isroot":false,"parentId":"220","text":"CAS问题"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"244","isroot":false,"parentId":"220","text":"原子操作类"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"245","isroot":false,"parentId":"221","text":"线程安全性"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"246","isroot":false,"parentId":"221","text":"死锁"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"247","isroot":false,"parentId":"221","text":"活锁"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"248","isroot":false,"parentId":"221","text":"线程饥饿"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"249","isroot":false,"parentId":"221","text":"黄金原则"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"250","isroot":false,"parentId":"221","text":"线程引入的开销"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"251","isroot":false,"parentId":"221","text":"如何减少锁的竞争"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"252","isroot":false,"parentId":"222","text":"JMM定义"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"253","isroot":false,"parentId":"222","text":"Java内存模型"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"254","isroot":false,"parentId":"222","text":"volatile"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"255","isroot":false,"parentId":"222","text":"final"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"256","isroot":false,"parentId":"222","text":"锁的内存语义"},{"direction":"right","hasRemark":"0","hasSubtree":"0","id":"257","isroot":false,"parentId":"222","text":"synchronized的实现原理"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"258","isroot":false,"parentId":"223","text":"Lock接口和核心方法"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"259","isroot":false,"parentId":"223","text":"Lock接口和synchronized的比较"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"260","isroot":false,"parentId":"223","text":"可重入锁ReentrantLock、所谓锁的公平和非公平"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"261","isroot":false,"parentId":"223","text":"ReadWriteLock接口和读写锁ReentrantReadWriteLock"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"262","isroot":false,"parentId":"223","text":"Condition接口"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"263","isroot":false,"parentId":"223","text":"LockSupport工具"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"264","isroot":false,"parentId":"224","text":"基本概念"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"265","isroot":false,"parentId":"224","text":"模板方法设计模式"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"266","isroot":false,"parentId":"224","text":"AQS数据结构"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"267","isroot":false,"parentId":"225","text":"哈希算法"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"268","isroot":false,"parentId":"225","text":"ConcurrentHashMap1.7"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"269","isroot":false,"parentId":"225","text":"ConcurrentHashMap1.8"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"270","isroot":false,"parentId":"225","text":"ConcurrentSkipList"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"271","isroot":false,"parentId":"225","text":"队列"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"273","isroot":false,"parentId":"226","text":"ThreadPoolExecutor 类"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"750","isroot":false,"parentId":"226","text":"线程池的意义"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"751","isroot":false,"parentId":"226","text":"线程池的创建参数含义"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"752","isroot":false,"parentId":"226","text":"线程池的工作机制"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"753","isroot":false,"parentId":"226","text":"预定义线程池"},{"direction":"left","hasRemark":"0","hasSubtree":"0","id":"754","isroot":false,"parentId":"226","text":"CompletionService"}];
            hym.sceneHandler = new SceneHandler(hym);
            hym.show();
            
        </script>

    </body>
</html>